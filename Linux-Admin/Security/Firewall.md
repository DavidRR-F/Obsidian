
A network security device or software application that is designed to monitor, filter, and control incoming and outgoing network traffic based on a set of predetermined security rules. Firewalls act as a barrier between a trusted internal network (such as a corporate network or home network) and untrusted external networks (such as the internet) to protect the internal network from unauthorized access, cyberattacks, and other security threats.

![[Pasted image 20231108185224.png]]

# 2 Types of firewalls

### Hardware Firewall

- **Physical Device**: A hardware firewall is a dedicated physical device designed to act as a network security barrier. It is often a standalone appliance or router with built-in firewall capabilities.
    
- **Deployment Location**: Hardware firewalls are typically placed at the network perimeter, between an organization's internal network and the external network (e.g., the internet). They are often used in corporate environments to protect the entire network.
    
- **Protection Scope**: Hardware firewalls provide network-level protection. They filter and control incoming and outgoing traffic based on predefined rules and policies. They can examine packets and connections and make decisions about allowing or blocking traffic at the network and transport layers.
    
- **Scalability**: Hardware firewalls can handle a large volume of network traffic and are suitable for protecting entire networks. They are scalable and can be configured to protect multiple devices and users simultaneously.
    
- **Ease of Use**: Hardware firewalls are relatively easy to set up and manage, making them a good choice for organizations that require network-wide security.
    
- **Examples**: Cisco ASA, Palo Alto Networks Firewall, Fortinet FortiGate.
### Software Firewall

-  **Software Application**: A software firewall is a software application or program that runs on an individual device, such as a computer or server. It is installed and configured on the operating system of the device.
    
- **Deployment Location**: Software firewalls are typically installed on individual devices, including desktops, laptops, and servers. Each device may have its own software firewall.
    
- **Protection Scope**: Software firewalls provide host-level protection. They are designed to filter traffic on a per-device basis and control which applications and services are allowed to communicate over the network.
    
- **Customization**: Software firewalls offer more granular control and customization options. Users can define specific rules for each device, specifying which applications or ports are allowed or blocked.
    
- **Scalability**: Software firewalls are suitable for protecting individual devices but may not be as scalable as hardware firewalls when it comes to protecting entire networks.
    
- **Ease of Use**: Software firewalls can be easy to install and configure on a per-device basis. They provide users with control over the security settings of their own devices.
    
- **Examples**: Windows Firewall (built into Windows OS), iptables (Linux), macOS Firewall (built into macOS).

# 2 Tools to manage firewall

### `iptables`

a command-line utility and framework used for configuring and managing packet filtering rules in the Linux kernel's netfilter framework. It is an essential component of the Linux firewall, allowing administrators to define rules that control the flow of network traffic into and out of a Linux-based system. `iptables` provides a powerful and flexible means of setting up firewall rules, network address translation (NAT), and packet mangling for various network-related tasks.

Install iptables

```bash
$ yum install iptable-services
```

Check iptables rules

```bash
$ iptables -L
```

![[Pasted image 20231108202105.png]]

flush iptables which removes all rules in the specified chain or all

```bash
$ iptables -F
```

## Packet Filtering

![[Pasted image 20231108200642.png]]

The function of the iptables tool is packet filtering. The packet filtering mechanism is organized into three different kinds of structures: tables, chains, and targets.

### Tables

A table allows you to process packets in specific ways. There are four kinds of tables: filter, mangle, nat , and raw

1. **Filter Table (`filter`)**:
    
    - **Purpose**: The `filter` table is the default and most commonly used table in `iptables`. It is primarily used for packet filtering and making decisions about whether to allow or block packets based on defined rules.
        
    - **Chains**: The `filter` table contains three main chains:
        
        - `INPUT`: Rules in this chain control incoming packets destined for the local system.
        - `OUTPUT`: Rules in this chain control outgoing packets generated by the local system.
        - `FORWARD`: Rules in this chain control packets that are forwarded between network interfaces (used in routing scenarios).

    - **Typical Use Cases**: The `filter` table is used for basic firewalling tasks, such as allowing or blocking specific ports or services, implementing access control policies, and setting up rules for network security.
        
2. **Mangle Table (`mangle`)**:
    
    - **Purpose**: The `mangle` table is used for packet mangling, which involves altering the packet headers or contents in various ways. This table is often used for advanced network manipulation tasks.
        
    - **Chains**: The `mangle` table contains the following chains:
        
        - `PREROUTING`: Rules in this chain are applied to packets as they enter the system, before any routing decisions are made.
        - `OUTPUT`: Rules in this chain are applied to locally generated packets before they are sent out.
        - `INPUT`: Rules in this chain are applied to packets destined for the local system after routing decisions.
        - `FORWARD`: Rules in this chain are applied to packets being forwarded between network interfaces.
        - `POSTROUTING`: Rules in this chain are applied to packets as they leave the system, after routing decisions.

    - **Typical Use Cases**: The `mangle` table can be used for tasks like altering the Time To Live (TTL) field in packets, marking packets for specific routing or QoS (Quality of Service) treatment, or implementing specialized network policies.
        
3. **NAT Table (`nat`)**:
    
    - **Purpose**: The `nat` (Network Address Translation) table is used for configuring network address translation, which involves modifying the source or destination IP addresses and ports in packets to facilitate routing between private and public networks.
        
    - **Chains**: The `nat` table contains three main chains:
        
        - `PREROUTING`: Rules in this chain are applied to packets as they enter the system, before routing decisions are made.
        - `POSTROUTING`: Rules in this chain are applied to packets as they leave the system, after routing decisions.
        - `OUTPUT`: Rules in this chain are applied to locally generated packets before they are sent out.

    - **Typical Use Cases**: The `nat` table is used for tasks like port forwarding, source NAT (SNAT), destination NAT (DNAT), and setting up network address translation rules to allow multiple devices on a private network to share a single public IP address.
        
4. **Raw Table (`raw`)**:
    
    - **Purpose**: The `raw` table is used for configuring exemptions or special handling of packets before connection tracking occurs. It is often used when you want to make decisions based on the original, untouched packet headers.
        
    - **Chains**: The `raw` table contains two main chains:
        
        - `PREROUTING`: Rules in this chain are applied to packets as they enter the system, before connection tracking takes place.
        - `OUTPUT`: Rules in this chain are applied to locally generated packets before connection tracking.

    - **Typical Use Cases**: The `raw` table is used for scenarios where you need to bypass connection tracking for specific packets or protocols. It's typically used in advanced networking setups where fine-grained control over packet handling is required.
### Chains

Each chain is attached to tables. These chains allow you to inspect traffic at various points and add rules to incoming traffic. There are three main chains in iptables: INPUT, FORWARD, and OUTPUT

1. **INPUT Chain**:
    
    - **Purpose**: The `INPUT` chain is responsible for processing incoming packets destined for the local system. It is the first chain that incoming packets encounter after they arrive at one of the system's network interfaces.
        
    - **Typical Use Cases**:
        
        - Filtering incoming traffic to determine which packets are allowed to reach local services and applications running on the system.
        - Implementing security policies to control access to specific services or ports on the local system.
        - Enforcing network-level access control and authentication for incoming connections.

    - **Example Rules**:
        
        - Allow incoming SSH (Secure Shell) traffic from a specific source IP address.
        - Block all incoming traffic on a specific port.

1. **FORWARD Chain**:
    
    - **Purpose**: The `FORWARD` chain is responsible for processing packets that are being forwarded between network interfaces on the system. It is typically used on systems functioning as routers or gateways that pass traffic from one network segment to another.
        
    - **Typical Use Cases**:
        
        - Filtering and controlling packets that are being forwarded between different network segments.
        - Implementing access control and security policies for traffic that is passing through the system.
        - Ensuring that packets are properly routed between networks.

    - **Example Rules**:
        
        - Allow traffic to be forwarded between a local network and the internet.
        - Block specific traffic from one network segment to another.

1. **OUTPUT Chain**:
    
    - **Purpose**: The `OUTPUT` chain is responsible for processing locally generated packets before they are sent out from the system. It is the last chain that outgoing packets encounter before leaving the system.
        
    - **Typical Use Cases**:
        
        - Applying rules and restrictions to locally generated traffic, such as blocking or controlling which services can initiate outgoing connections.
        - Implementing egress filtering to enforce security policies for outgoing traffic.

    - **Example Rules**:
        
        - Allow local services to access the internet.
        - Restrict certain applications from making outbound connections.

### Targets

A target decides the fate of a packet, such as allowing or rejecting it. There are 3 different types of targets: ACCEPT, REJECT, and DROP

1. **ACCEPT**:
    
    - **Purpose**: When a packet matches a rule with the `ACCEPT` target, it means that the packet is allowed to pass through the firewall, and it will be permitted to reach its intended destination.
        
    - **Effect**: The packet is accepted and forwarded to its destination or service as specified by the rule. No further processing is performed on the packet within the chain.
        
    - **Use Cases**:
        
        - Allowing legitimate traffic to pass through the firewall.
        - Permitting access to specific services or ports.

    - **Example Rule**:
        
        - Allow incoming SSH traffic:
            
```bash
$ iptables -A INPUT -p tcp --dport 22 -j ACCEPT
```
            
2. **REJECT**:
    
    - **Purpose**: When a packet matches a rule with the `REJECT` target, it means that the packet is denied, and the sender of the packet is immediately notified that their packet has been rejected.
        
    - **Effect**: The packet is rejected, and an ICMP (Internet Control Message Protocol) response or other appropriate response is sent to the sender, informing them that the packet was not accepted. The sender is made aware that their connection attempt was unsuccessful.
        
    - **Use Cases**:
        
        - Blocking unwanted or malicious traffic and informing the sender that access is denied.
        - Providing feedback to the sender about why their connection request was denied.

    - **Example Rule**:
        
        - Reject incoming HTTP traffic:
            
```bash
$ iptables -A INPUT -p tcp --dport 80 -j REJECT
```
            
3. **DROP**:
    
    - **Purpose**: When a packet matches a rule with the `DROP` target, it means that the packet is denied, and no response or notification is sent to the sender. The packet is silently discarded.
        
    - **Effect**: The packet is discarded, and no acknowledgment or rejection message is sent to the sender. From the sender's perspective, it appears as if the packet simply disappeared.
        
    - **Use Cases**:
        
        - Blocking unwanted or malicious traffic without providing feedback to the sender.
        - Stealthily dropping packets to avoid revealing the existence of the firewall.

    - **Example Rule**:
        
        - Drop all incoming ICMP (ping) traffic:

```bash
$ iptables -A INPUT -p icmp -j DROP
```

### `firewalld`

A dynamically managed firewall solution that is used to configure and manage network filtering rules in many Linux distributions, including CentOS, Red Hat Enterprise Linux (RHEL), Fedora, and others. It provides a higher-level, more user-friendly interface for managing firewall rules compared to traditional tools like `iptables`. `firewalld` is designed to simplify the process of configuring and maintaining firewalls, making it accessible to both system administrators and end-users.

Firewalld work the same way as iptables but it has it own commands: `firewall-cmd` and has few pre-defined service rules that are very easy to turn on and off: NFS, NTP, HTTPD, etc. and has similar concepts to iptables:

- Table
- Chains
- Rules
- Targets

Get list of rules

```bash
$ firewall-cmd --list-all
```

Get list of services

```bash
$ firewall-cmd --get-services
```

Reload after adding rules

```bash
$ firewall-cmd --reload
```

